/*
 * generated by Xtext 2.10.0
 */
package com.laegler.stubbr.lang.jvmmodel

import com.google.inject.Inject
import com.laegler.stubbr.lang.stubbrLang.Stubb
import org.eclipse.xtext.xbase.jvmmodel.AbstractModelInferrer
import org.eclipse.xtext.xbase.jvmmodel.IJvmDeclaredTypeAcceptor
import org.eclipse.xtext.xbase.jvmmodel.JvmTypesBuilder
import org.eclipse.xtext.naming.IQualifiedNameProvider
import com.laegler.stubbr.lang.stubbrLang.Entity
import org.eclipse.xtext.common.types.JvmTypeReference

class StubbrLangJvmModelInferrer extends AbstractModelInferrer {

	@Inject extension JvmTypesBuilder

	@Inject extension IQualifiedNameProvider

	def dispatch void infer(Stubb element, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {
// 		acceptor.accept(element.toClass("my.company.greeting.MyGreetings")) [
// 			for (greeting : element.greetings) {
// 				members += greeting.toMethod("hello" + greeting.name, typeRef(String)) [
// 					body = '''
//						return "Hello «greeting.name»";
//					'''
//				]
//			}
//		]
	}

	def dispatch void infer(Entity entity, IJvmDeclaredTypeAcceptor acceptor, boolean isPrelinkingPhase) {
		acceptor.accept(entity.toClass(entity.fullyQualifiedName)) [
			documentation = entity.documentation

			if (entity.superType != null)
				superTypes += entity.superType.cloneWithProxies

			for (attribute : entity.attributes) {
				switch attribute {
//					JvmTypeReference: {
//						members += attribute.toField(attribute.name, attribute.type)
//						members += attribute.toGetter(attribute.name, attribute.type)
//						members += attribute.toSetter(attribute.name, attribute.type)
//					}
//					Operation: {
//						members += attribute.toMethod(attribute.name, attribute.type) [
//							documentation = attribute.documentation
//							for (p : attribute.params) {
//								parameters += p.toParameter(p.name, p.parameterType)
//							}
//							body = feature.body
//						]
//					}
				}
			}
		]
	}
}
